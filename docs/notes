Yevgeniya
=========

This file contains notes for 'yevgeniya', a successor to nomad.

The language is a testbed for various ideas I've had
over the years.  I would see if it's possible to make a language
with an interpreter and compiler that would help catch the errors
I make - or even eliminate some of them altogether.
It would be interesting to work out 
what the trade-offs are.

Some of the ideas I'd like to experiment with include:

1. use of uninitialized variables (read with no prev write, or uninit read)
2. dead writes (writes with no intervening reads)
3. terminal writes (writes to loc var with no subsequent read)
4. no global variables
5. partial IF/CASEs (non-exhaustive conditions)
6. overlapping IF/CASEs.
6. problems with dynamic memory allocation
   (read before alloc, read after alloc but 
   before init, read after free, double free)

characteristics of the language.

* like Pascal, the language is imperative.
* syntax influenced by Pascal and PL/0.
* separate compilation (PROGRAM and UNIT subprograms).
* all elements defined in a UNIT are exported.  a client 
  program or unit imports the contents of UNIT with a USE 
  statement.  the access to contents of an imported UNIT are 
  fully qualified, and there is no way to get unqualified 
  import.
* there are no comments in the language.  comment-like 
  features are achieved via a literate programming tool 
  like cobweb or a notebook environment like jupyter.
* program files are encoded in UTF8.
* there should be a standard program formatter (like gofmt).
* there are no global variables.
* there are no nested procedure definitions.
* PROCEDUREs and FUNCTIONs.  although there are no tuple types, a 
  function may return multiple results.
* procedures have in-only or in-out parameters.  functions have 
  in-only and out-only parameters.
* out-only function parameters must be allocated in the caller.
* parameter passing modes are constant, reference (VAR) and result.
* types are basic (BOOLEAN, BYTE, INTEGER, RATIONAL), compound 
  (ARRAY, RECORD), and other types (FILE, pointers, subranges, 
  and user-defined types).
* procedures and functions may be passed as arguments, but not returned as 
  results.  there are no procedure or function literals.
* array references are always bounds-checked.
* IF-ELIF construct and CASE construct are total - one 
  branch must succeed.  every run implies evaluation of all 
  branches.  if there are multiple true branches, a true 
  branch is chosen with the aid of a simple pseudorandom 
  number generator.  if there is no true branch, the program 
  halts with a diagnostic message.
* in an assignment, the order of evaluation of r.h.s. 
  expressions cannot change the value produced for the 
  l.h.s. assignment target.
* a pointer value that is "before" its initial association 
  (NEW) or "after" a DISPOSE, is in an uninitialized state.
* there are no exceptions in the language.  a fatal error 
  causes the program to halt with appropriate diagnostics.

Types in the language
---------------------

basic types ::

 INTEGER, RATIONAL, BYTE, BOOLEAN.

 An INTEGER is a element of a subrange MIN_INTEGER .. MAX_INTEGER, 
 where these are implementation-defined (16, 32, or 64 bit).
 The initial test implementation will use int16 for INTEGER.

 a RATIONAL is a ratio expressed by two INTEGER values.

 a BYTE is conceptually subrange with values 0...255, but implemented
 as a uint8.

miscellaneous types ::

	subranges: e.g. 0..255.
	pointers: e.g. ^T.
	files: FILE of T.

compound types (containing multiple values) - arrays and records :: 

	ARRAY N OF T. 
	STRING is just ARRAY OF BYTE.
	RECORD field (";" field)* END.

A non-var formal parameter of pointer type cannot appear 
inside its procedure as the target of an assignment, more 
generally this constraints applies to any non-var formal 
parameter.

The language does not provide a way to declare a variable 
in an initialized state.  For a compound type, there is a 
way to initialize the variable at runtime with a literal: ::

 array:   a := array(1,2,3);   (number of elements must equal size of array)
 record:  r := rtype(1, 2.0); 

These multi-element literals in assignments are just 
syntactic sugar for a sequence of assignments performed
left to right that perform the equivalent initialization, .

The interpreter should collect information to help detect the following 
conditions:

1. the use of an uninitialized variable. (read with no 
   previous write in a single scope.) (uninit read)
2. dead assignments. (write x followed by write x in a 
   single scope with no intervening read.)  (dead write)
3. write with no subsequent read for a non-returned local 
   variable or VAR parameter. (terminal write).

consider finding the max value in an array. ::

	max := 0;
	for i := 0 to len(A)-1 do 
		if a[i] > max then
			max = a[i]
		elif a[i] <= max then
			skip
		end
	end

It appears that for each variable, there is a pattern of 
write-read in use.  If we represent a write operation 
as 'w' and a read as 'r', the succession of access for 
a given variable should match one of the
following regular expressions. ::

 constants and constant parameters:	r+
 local variables: 			(wr+)+
 VAR parameter (used in-out):		(r+w)+r*
 VAR parameter (used in): 		r+
 VAR parameter (used out): 		w

 there may be a case where a read-write pattern of (wr)+
 makes sense.  this would be a variable whose writes and reads
 strictly alternate.

thoughts about maps
-------------------

Golang uses the name 'maps' to refer to associative arrays.
It would be convenient to provide a standard associative array 
in the language.  In Yevgenia, these are called 'tables'.

A table is a dynamically resizeable associative array.  It is 
provided by an abstract unit 'table' with some default procedures. ::

	SIGNATURE tablevar; 
		table_type: typevar;
		procedure init(var t: table_type);
		function first_key(t: table_type -> k: key_type); 
		function next_key(k, t: table_type -> rk: key_type); 
		function is_last_key(k, t: table_type -> b: boolean); 
		function get(t: table_type, k: key_type 
			-> v: value_type, b: boolean);
		procedure set(t: table_type, k: key_type, v: value_type); 
	END; 

one would iterate over a table with code like: ::

	var t: si_table;
	begin ...
		si_table.init(t, k0);
		k := k0
		while not si_table.last(k) do 
			val, present := si_table.get(k)
			if present then
				do stuff with val.
				k := si_table.next(k)
			elif not present then 
				error	
			end;
		end;
	end;

strings in yevgeniya
--------------------

a string is just an array of byte, with a presumed 
encoding of utf-8.  the set of supported code points 
must at least include ascii + the unicode replacement 
character, but may include more.

how to iterate over a string, getting the unicode characters.::

	const MAX_CODE_POINT = 65533;
	type u8char_t = 0..MAX_CODE_POINT;
	var uc: u8char_t; 
	begin
		s := 'hello, world';
		i := 0;
		while i < len(s) do 
			uc, i := u8char(s, i);
			...use char value in uc...
		end
	end

The ORD intrinsic takes a utf8 byte array and returns the 
code point associated with the left-most unicode character 
in the array.  The CHR intrinsic takes an integer code point 
and returns a byte array (utf8) of the corresponding
unicode character.

simple i/o
----------

There are a number of statements built-in to the 
language to enable simple text i/o without the use 
of imported units. ::

	READ, READLN
	WRITE, WRITELN
	ASSIGN, OPEN, CLOSE, SEEK, TELL

abstract units
--------------

An *abstract unit* is a unit that accepts parameters.  These 
parameters are signatures.  An abstract unit is instantiated 
into a *concrete unit* via a USE..AS statement, e.g. 

	USE ABS_UNIT(SIG) AS CONC_UNIT;

(Normal units are concrete units.)

A *signature* is a top level construct that records the
type of a unit.  A signature contains type signatures
of named types, constants, record types and procedures.

A units is either concrete or abstract. The former
is the more common of the two - in some sense the normal
meaning of 'unit', absent qualification.

Another take on abstract units.  Consider how an ML functor 
works, acting as a function that takes a structure and 
returns a structure.  Here, we would have a way to 
take an abstract unit and a signature argument, 
and produce a concrete unit.

UNIT IORDER;  
	(* concrete unit for integer comparison *)
	TYPE ALPHA = INTEGER;
	
	FUNCTION LT(A, B: ALPHA -> RV: BOOLEAN);
		BEGIN
			IF A < B THEN
				RV := TRUE
			ELIF A >= B THEN
				RV := FALSE
			END
		END;

	PROCEDURE COPY(VAR A: ALPHA; B: ALPHA);
		BEGIN
			A := B
		END
END;

-------------------------------------------
another idea:

SIGNATURE ORDER;
	ALPHA: TYPEVAR;
	LT   : FUNCTION(A, B: ALPHA -> RV: BOOLEAN);
	COPY : PROCEDURE(VAR A: ALPHA; B: ALPHA);
END

-------------------------------------------

UNIT SORTER(ABS_ORD: ORDER);

	PROCEDURE SORT(VAR A: ARRAY OF ABS_ORD.ALPHA);
		VAR
			I, J : INTEGER;
			TMP  : ABS_ORD.ALPHA;
	BEGIN
		FOR I := 0 TO LEN(A)-2 DO 
			FOR J := I+1 TO LEN(A)-1 DO 
				IF ABS_ORD.LT(A[I], A[J]) THEN
					ABS_ORD.COPY(TMP, A[I]);
					ABS_ORD.COPY(A[I], A[J]);
					ABS_ORD.COPY(A[J], TMP)
				ELIF NOT ABS_ORD.LT(A[I], A[J]) THEN
					SKIP
				END
			END
		END
	END (* SORT *)

END; (* SORTER *)

and the client code that wants to use an integer sorter.

program green;
	use iorder;
	use sorter(iorder) as isorter;
	var 
		a: array 10 of integer
begin
	a := array(3,1,4,1,5,9,2,6,5);
	isorter.sort(a);
	write(a)
end

const-ness and pointers
-----------------------

A constant pointer argument (one declared without VAR) cannot 
be modified in a procedure call, nor can it be modified in 
a yet-more-deeply nested procedure call.  For pointer 
arguments, this constraint applies to the pointer itself, 
not to fields of the pointer variable (should the pointer 
designate a record type, say).  So this is not allowed:

	PROCEDURE NEW_NODE(P: ^NODE); BEGIN NEW(P) END;

but the following is allowed:

	PROCEDURE INC(P: ^NODE); BEGIN P^.VALUE := P^.VALUE + 1 END;

(The "once const always const" constraint 
applies to all constant args in general.)

result parameters
-----------------

use result parameters (out-only parameters) for functions 
that return one or more results.

function inc(j: integer -> k: integer);
begin
	k := j + 1
end

function divmod(a, b: integer -> quo, rem: integer); 
begin
	quo := a div b; 
	rem := a mod b
end

for procedures, use var parameters for in-out parameters.

procedure halve(a: var array array integer);
	var i, j: integer;
begin
	for i in range(a, 1) do 
		for j in range(a, 2) do 
			a[i][j] := a[i][j] div 2
		end
	end
end

non-result non-var parameters are constant (in-only) parameters, 
and may not be changed in the procedure.

for-loops.

normal indexed for..to loop, iterating over an array.
	for i := 0 to len(a)-1 do .. end.
ranging over the first dimension of an array:
	FOR I := LBOUND(A, 1) TO UBOUND(A, 1) DO .. END
or just
	FOR I := LBOUND(A) TO UBOUND(A) DO .. END

syntax for R17 Subset 1, based on PL/0.

program = PROGRAM name ";" pblock.
pblock = c-part? v-part? pdecl-list? BEGIN statement-list END.
c-part = CONST name "=" literal (";" name "=" literal)*.
v-part = VAR vdecl (";" vdecl)*. 
vdecl = name-list ":" type.
name-list = name ("," name)*. 
type = INTEGER | BOOLEAN.
pdecl-list = pdecl (";" pdecl)*.
pdecl = pheader block.
pheader = PROCEDURE name "(" parm-list ")" result? ";"
parm-list = parm (";" parm)*.
parm = VAR? name-list ":" type.
result = RESULT "(" vdecl (";" vdecl)* ")". 
block = c-part? v-part? BEGIN statement-list END.

statement = assign | call | read | write | while | if.
assign = name-list ":=" expression.
call = name "(" expression-list ")". 
expression-list = expression ("," expression)*. 
read = READ name-list.
write = WRITE expression-list.
while = WHILE condition DO statement-list END.
statement-list = statement (";" statement-list)*. 
if = IF condition THEN statement-list 
	(ELIF condition THEN statement-list)+ END.

condition = expression (("="|"<>"|"<"|"<="|">"|">=") expression)? .
expression = term (("+"|"-"|OR) term)*. 
term = factor (("*"|DIV|AND) factor)*.
factor = name | literal | unop factor | "(" expression ")" | call.
literal = TRUE | FALSE | integer-literal.
unop = "-" | NOT.


Nondeterminism and the IF statement
-----------------------------------

In Yevgenia, the if-statement has several aspects which the Pascal
programmer will find unconventional.

1. There is no "ELSE" branch.
2. Every branch condition is tested when executing the if statement.
3. At least one branch must evaluate to true.  If no branches evaluate
   to true, the program halts with an error.
4. If more than one branch is true, a true branch is selected using 
   some method and executed.  The choice of true branch to run is 
   made at run-time.  This implies that the program could produce different
   results on different runs with the same input data.
5. If the lexical order of if-branches changes the output of the program,
   the program should be considered defective, even though the compiler 
   itself doesn't detect or report this.

For the first implementation of the language, compile-time
test order randomization (option 4a) will be done.

The case statement, similarly, lacks an else part, and requires that 
one of the cases evaluate to true.  The case-statement
differs from the if-statement in that *exactly* one 
branch must be true.

Consider the if-statement

	if C1 then S1
	elif C2 then S2
	elif C3 then S3 end

Using compile-time (3a) 'test order randomization', this code might be 
evaluated as if it were written in a different order:

	if C2 then S2
	elif C1 then S1
	elif C3 then S3 end

Assuming that the programmer uses regression tests, if a program 
fails following a recompile, this indicates an order dependency 
defect in an IF-statement.

The requirement for multiple tools in normal development
========================================================

Normal development of a unit requires running multiple tools.

* the interpreter (one or more runs) to collect access data
  on all constants and variables.
* the sprinkler (one run) to analyze the body of interpreter
  runs for for two kinds of problems: 
  + access problems :
    - uninitialized variable reads (read before write to a var)
    - dead writes (two writes to a var with no intervening read)
    - terminal writes (write to a var with no subsequent read)
  + coverage problems : the set of interpreter runs should include
    data showing each line being run at least once. 
  if problems are found, they will be reported, and if no 
  problems are found, a "blessing" is issued (sprinkler is 
  short for "holy water sprinkler")
* the compiler (one run) takes one or more blessed units 
  compiles it/them into either a library or an executable
  program.

The interpreter will have a mode in which the reads and writes
that happen on each lexical line of code in a file is recorded.

The information recorded needs to be enough to allow line
coverage to be worked out, and enough to follow a variable
in its home scope and all its subordinate scopes.  This
information should include: file md5, unit name, proc name,
temporal line number, physical line number, local var name,
true var name (unit/proc/localname), local "const-var-type",
true "const/var type", read/write marker.

The information the interpreter saves for the code in a
file is saved in the interpretation (or interpreter) record.
Probably I would save this information in an SQLite database.
The sprinkler will look at the interpretation record to look
for coverage and access problems.

When the sprinkler is given a file to check, it will require
a full set of interpreter records for that file (with the
same MD5 as the current file) to successfully bless the file.

I could use an Adler-32 checksum instead of an MD5.  The intent
of identifying a file by checksum or hash is not to prevent
mischief, but to make it possible for a programmer to get
a positive assurance that the access characteristics of the
file's variables and constants are what the compiler expects.
Having 100% line coverage is not an end in itself, but just
a way to get a strong approximation of each variable's full
access history.

The access history of a single run must conform to the all
variables "const-var-type".  Further, each single run must
(minimally) exit without error.  When the sprinkler analyzes
the collective history of all runs, this analysis must show
that every read-use and write-use of each variable has been
recorded in at least one run.  (we know we have every var
examined when we have 100% line coverage.)

The compiler will only compile blessed files.

If Yevgenia source files are shared, I would expect that the
shared artifacts would include not just the source files,
but also any scripts and input data required to reproduce
blessed units with the sprinker.

Making programming easier
-------------------------

A number of Yevgeniya's features (like the nondeterministic
IF statement, the total CASE statement, the whole deal 
of blessing via the sprinkler) on the face of it make 
programming harder.  It will be interesting to see if 
these features are a net plus or minus (and plus or minus
with respect to what ends).

thoughts on nondeterministic if
-------------------------------

say you start out with code like: ::

	if C1 then S1
	elif C2 then S2
	elif C3 then S3 end.

at runtime generate three random numbers (corresponding with 
branch conditions C1, C2, C3.  Call these three random numbers
R1, R2, R3.   consider implementing the nondeterministic if with 
logic like :: 

	xprev = 1	--seed
	..
	rand(xprev)
		a = 209
		m = 4093
		xnext = a * xprev mod m 
		return xnext

	idea 3
		(best idea so far for runtime test order randomization.)
		rmax = -1
		r1 = -1 
		r2 = -1
		r3 = -1 
		if C1 then r1 = rand() ; rmax = max(r1, rmax) end
		if C2 then r2 = rand() ; rmax = max(r2, rmax) end
		if C3 then r3 = rand() ; rmax = max(r3, rmax) end
		if   r1 == rmax then S1
		elif r2 == rmax then S2
		elif r3 == rmax then S3
		else
			fail, no true branch
		end

	000000000000000000000000000000

	idea 6, another try at round robin.

		(at start of scope) offset = 0 
		...
		b[0] = C0 ; b[1] = C1 ; b[2] = C2 
		for i 0 to 2 do
			k = (i+offset) % 3
			if   k==0 and b0 then S0
			elif k==1 and b1 then S1
			elif k==2 and b2 then S2
			else
				fail, no true branch
			end
		end
		offset = offset + 1

	000000000000000000000000000000
 
[end of file]
