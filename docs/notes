Yevgeniya
=========

This file contains notes for 'yevgeniya', a successor to nomad.

The language is a testbed for various ideas I've had
over the years.  I would see if it's possible to make a language
and compiler that do a better job of catching the typical
kinds of errors I make - and if it's possible, to work out 
what the trade-offs are.

Some of the errors I'd like the compiler to help find include:

1. use of uninitialized variables.  (read with no prev write)
2. write-write with no intervening read.
3. write to local var with no subsequent read.
4. problems with global variables.
5. problems with aliasing.
6. problems with dynamic memory allocation
   (read before alloc, read after alloc but 
   before init, read after free, double free)

characteristics of the language or its reference implementation.

* like Pascal, the language is imperative.
* syntax influenced by Pascal and PL/0.
* separate compilation (PROGRAM and UNIT subprograms).
* all elements defined in a UNIT are exported.  a client 
  program or unit imports the contents of UNIT with a USE 
  statement.  the access to contents of an imported UNIT are 
  fully qualified, and there is no way to get unqualified 
  import.
* there are no comments in the language.  comment-like 
  features are achieved via a literate programming tool 
  like cobweb.
* program files are encoded in UTF8.
* there should be a standard program formatter (like gofmt).
* there are no global variables.
* there are no nested procedure definitions.
* PROCEDUREs but no FUNCTIONs.  procedures are either proper
  or value-returning.  although there are no tuple types, a 
  procedure may return multiple results.
* procedures may have in-only parameters, and either 
  var or result parameters but not both.
* result parameters must be allocated in the caller.
* parameter passing modes are constant, reference and result.
* types are basic (BOOLEAN, BYTE, INTEGER, RATIONAL), compound 
  (ARRAY, RECORD), and other types (FILE, pointers, subranges, 
  and user-defined types).
* procedures may be passed as arguments, but not returned as 
  results.  there is no procedure literal.
* array references are always bounds-checked.
* IF-ELIF construct and CASE construct are total - one 
  branch must succeed.  every run implies evaluation of all 
  branches.  if there are multiple true branches, a true 
  branch is chosen with the aid of a simple pseudorandom 
  number generator.  if there is no true branch, the program 
  halts with a diagnostic message.
* in an assignment, the order of evaluation of r.h.s. 
  expressions cannot change the value produced for the 
  l.h.s. assignment target.
* a pointer value that is "before" its initial association 
  (NEW) or "after" a DISPOSE, is in an uninitialized state.
* there are no exceptions in the language.  a fatal error 
  causes the program to halt with appropriate diagnostics.

Types in the language
---------------------

basic types ::

 INTEGER, RATIONAL, BYTE, BOOLEAN.

 An INTEGER is a element of a subrange 
   MIN_INTEGER .. MAX_INTEGER, 
 where these are implementation-defined (probably close to -2**31
 and 2**31).

 a RATIONAL is a ratio expressed by two INTEGER values.

miscellaneous types ::

	subranges: e.g. 0..255.
	pointers: e.g. ^T.
	files: FILE of T.

compound types (containing multiple values) - arrays and records :: 

	ARRAY N OF T. 
	STRING is just ARRAY OF BYTE.
	RECORD field (";" field)* END.

A non-var formal parameter of pointer type cannot appear 
inside its procedure as the target of an assignment, more 
generally this constraints applies to any non-var formal 
parameter.

The language does not provide a way to declare a variable 
in an initialized state.  For a compound type, there is a 
way to initialize the variable at runtime with a literal: ::

 array:   a := array(1,2,3);   (number of elements must equal size of array)
 record:  r := rtype(1, 2.0); 

These multi-element literals in assignments are just 
syntactic sugar for a sequence of assignments performed
left to right that perform the equivalent initialization, .

The interpreter should collect information to help detect the following 
conditions:

1. the use of an uninitialized variable. (read with no 
   previous write in a single scope.)
2. dead assignments. (write x followed by write x in a 
   single scope with no intervening read.)
3. write with no subsequent read for a non-returned local 
   variable or VAR parameter.

consider finding the max value in an array. ::

	max := 0;
	for i := 0 to len(A)-1 do 
		if a[i] > max then
			max = a[i]
		elif a[i] <= max then
			skip
		end
	end

It appears that for each variable, there is a pattern of 
write-read in use.  If we represent a write operation 
as 'w' and a read as 'r', the succession of access for 
a given variable should match one of the
following regular expressions. ::

 constants and constant parameters:	r+
 local variables: 			(wr+)+
 VAR parameter (used in-out):		(r+w)+r*
 VAR parameter (used in): 		r+
 VAR parameter (used out): 		w

 there may be a case where a read-write pattern of (wr)+
 makes sense.  this would be a variable whose writes and reads
 strictly alternate.

thoughts about maps
-------------------

For arrays, for-loops provide a way to iterate over the 
indexes of the array.  How would one iterate over the 
keys or values of a map variable? ::

 UNIT map(kt, vt: type);
	contains
		map_t - type for a map. 
		new - procedure to create a map of this type.
		get - procedure to retrieve value from map, given key.
		set - procedure to add value to map, given key.
		key_in - function to query if key is in map.
		iter_new - initialize an iterator.
		iter_next - get next value from map.
 END;
	...
	USE map(string, integer) AS simap;
	VAR m: simap.map_t; 
	...
	simap.set(m, 'a', 1);
	simap.set(m, 'b', 2);
	...
	if 'c' in m then ...
	elif 'c' not in m then ...
	end;
	...
	p := simap.iter_new(m);
	while p <> nil do 
		simap.iter_next(p, k, v);
		...p advanced by iter_next() call...
		...do something with k and v...
	end

strings in yevgeniya
--------------------

a string is just an array of byte, with a presumed 
encoding of utf-8.  the set of supported code points 
must at least include ascii + the unicode replacement 
character, but may include more.

how to iterate over a string, getting the unicode characters.::

	const MAX_CODE_POINT = 65533;
	type u8char_t = 0..MAX_CODE_POINT;
	var uc: u8char_t; 
	begin
		s := 'hello, world';
		i := 0;
		while i < len(s) do 
			uc, i := u8char(s, i);
			...use char value in uc...
		end
	end

The ORD intrinsic takes a utf8 byte array and returns the 
code point associated with the left-most unicode character 
in the array.  The CHR intrinsic takes an integer code point 
and returns a byte array (utf8) of the corresponding
unicode character.

simple i/o
----------

There are a number of statements built-in to the 
language to enable simple text i/o without the use 
of imported units. ::

	READ, READLN
	WRITE, WRITELN
	ASSIGN, OPEN, CLOSE, SEEK, TELL

abstract units
--------------

An *abstract unit* is a unit that accepts parameters.  These
parameters are signatures.
An abstract unit is instantiated into a 
*concrete unit* via a USE..AS statement, like

	USE  ABS_UNIT(SIG) AS CONC_UNIT;

(Normal units are concrete units.)

A *signature* is a special type of "sub unit" that only 
contains type signatures of named types, constants, record 
types and procedures.

A units is either concrete or abstract. The former
is the more common of the two - in some sense the normal
meaning of 'unit', absent qualification.

Another take on abstract units.  Consider how an ML functor 
works, acting as a function that takes a structure and 
returns a structure.  Here, we would have a way to 
take an abstract unit and a signature argument, 
and produce a concrete unit.

UNIT IORDER;  
	(* concrete unit for integer comparison *)
	TYPE ALPHA = INTEGER;

	PROCEDURE LT(A, B: ALPHA) RESULT (RV: BOOLEAN);
		BEGIN
			IF A < B THEN
				RV := TRUE
			ELIF A >= B THEN
				RV := FALSE
			END
		END;

	PROCEDURE COPY(VAR A: ALPHA; B: ALPHA);
		BEGIN
			A := B
		END
END;

SIGNATURE ORDER;  (* signature unit *)
	ALPHA: TYPEVAR;
	LT   : PROCEDURE(A, B: ALPHA) RESULT (RV: BOOLEAN);
	COPY : PROCEDURE(VAR A: ALPHA; B: ALPHA);
END;

ABSTRACT UNIT SORTER(ORDER: SIGNATURE);

	PROCEDURE SORT(VAR A: ARRAY OF ORDER.ALPHA);
		VAR
			I, J : INTEGER;
			TMP  : ORDER.ALPHA;
	BEGIN
		FOR I := 0 TO LEN(A)-2 DO 
			FOR J := I+1 TO LEN(A)-1 DO 
				IF ORDER.LT(A[I], A[J]) THEN
					ORDER.COPY(TMP, A[I]);
					ORDER.COPY(A[I], A[J]);
					ORDER.COPY(A[J], TMP)
				ELIF NOT ORDER.LT(A[I], A[J]) THEN
					SKIP
				END
			END
		END
	END (* SORT *)

END; (* SORTER *)

and the client code that wants to use an integer sorter.

program green;
	use iorder;
	use sorter(iorder) as isorter;
	var 
		a: array 10 of integer
begin
	a := array(3,1,4,1,5,9,2,6,5);
	isorter.sort(a);
	write(a)
end

const-ness and pointers
-----------------------

A constant pointer argument (one declared without VAR) cannot 
be modified in a procedure call, nor can it be modified in 
a yet-more-deeply nested procedure call.  For pointer 
arguments, this constraint applies to the pointer itself, 
not to fields of the pointer variable (should the pointer 
designate a record type, say).  So this is not allowed:

	PROCEDURE NEW_NODE(P: ^NODE); BEGIN NEW(P) END;

but the following is allowed:

	PROCEDURE INC(P: ^NODE); BEGIN P^.VALUE := P^.VALUE + 1 END;

(The "once const always const" constraint 
applies to all constant args in general.)

result parameters
-----------------

use result parameters (out-only parameters) for functions 
that return one or more results.

procedure inc(j: integer) result(k: integer);
begin
	k := j + 1
end

procedure divmod(a, b: integer) result(quo, rem: integer); 
begin
	quo := a div b; 
	rem := a mod b
end

use var parameters for in-out parameters.

procedure halve(a: var array array integer);
	var i, j: integer;
begin
	for i in range(a, 1) do 
		for j in range(a, 2) do 
			a[i][j] := a[i][j] div 2
		end
	end
end

consider how to encode preconditions and postconditions.

non-result non-var parameters are constant (in-only) parameters, 
and may not be changed in the procedure.

for-loops.

normal indexed for..to loop, iterating over an array.
	for i := 0 to len(a)-1 do .. end.
equivalent for..range loop:
	for i in range a do .. end.
range a is an abbreviation for range(a, 1) - 
which means "range over first dimension".
range(a,2) ranges over second dimension, etc.  say array a is an 
array of 10 booleans.
	VAR A: ARRAY 10 BOOLEAN;
the range notation means we vary the index over the acceptable
index values of the array, from smallest to greatest.  thus
	FOR I IN RANGE A DO .. END
is equivalent to 
	FOR I := LBOUND(A, 1) TO UBOUND(A, 1) DO .. END

syntax for R17 Subset 1, based on PL/0.

program = PROGRAM name ";" pblock.
pblock = c-part? v-part? pdecl-list? BEGIN statement-list END.
c-part = CONST name "=" literal (";" name "=" literal)*.
v-part = VAR vdecl (";" vdecl)*. 
vdecl = name-list ":" type.
name-list = name ("," name)*. 
type = INTEGER | BOOLEAN.
pdecl-list = pdecl (";" pdecl)*.
pdecl = pheader block.
pheader = PROCEDURE name "(" parm-list ")" result? ";"
parm-list = parm (";" parm)*.
parm = VAR? name-list ":" type.
result = RESULT "(" vdecl (";" vdecl)* ")". 
block = c-part? v-part? BEGIN statement-list END.

statement = assign | call | read | write | while | if.
assign = name-list ":=" expression.
call = name "(" expression-list ")". 
expression-list = expression ("," expression)*. 
read = READ name-list.
write = WRITE expression-list.
while = WHILE condition DO statement-list END.
statement-list = statement (";" statement-list)*. 
if = IF condition THEN statement-list 
	(ELIF condition THEN statement-list)+ END.

condition = expression (("="|"<>"|"<"|"<="|">"|">=") expression)? .
expression = term (("+"|"-"|OR) term)*. 
term = factor (("*"|DIV|AND) factor)*.
factor = name | literal | unop factor | "(" expression ")" | call.
literal = TRUE | FALSE | integer-literal.
unop = "-" | NOT.


Nondeterminism and the IF statement
-----------------------------------

In Yevgenia, the if-statement has several aspects which the Pascal
programmer will find unconventional.

1. There is no "ELSE" branch.
2. Every branch condition is tested when executing the if statement.
3. At least one branch must evaluate to true.  If no branches evaluate
   to true, the program halts with an error.
4. If more than one branch is true, a true branch is selected using 
   a pseudorandom number generator and executed.  The choice of true 
   branch could be done 
   a. at compile time, so multiple runs of the program on the same
      input with the same executable produce the same result, or 
   b. at execution time, so that even with the same input data and 
      the same executable, different runs could produce different results.
5. If the lexical order of if-branches changes the output of the program,
   the program should be considered defective, even though the compiler 
   itself doesn't detect or report this.

For the first implementation of the language, compile-time
test order randomization (option 4a) will be done.

The case statement, similarly, lacks an else part, and requires that 
one of the cases evaluate to true.  The case-statement
differs from the if-statement in that *exactly* one 
branch must be true.

Consider the if-statement

	if C1 then S1
	elif C2 then S2
	elif C3 then S3 end

Using compile-time (3a) 'test order randomization', this code might be 
evaluated as if it were written in a different order:

	if C2 then S2
	elif C1 then S1
	elif C3 then S3 end

Assuming that the programmer uses regression tests, if a program 
fails following a recompile, this indicates an order dependency 
defect in an IF-statement.

The requirement for multiple tools in normal development
========================================================

Normal development of a unit requires running multiple tools.

* the interpreter (one or more runs) to collect access data
  on all constants and variables.
* the sprinkler (one run) to analyze the body of interpreter
  runs for for two kinds of problems: 
  + access problems :
    - uninitialized variable reads (read before write to a var)
    - dead writes (two writes to a var with no intervening read)
    - terminal writes (write to a var with no subsequent read)
  + coverage problems : the set of interpreter runs should include
    data showing each line being run at least once. 
  if problems are found, they will be reported, and if no 
  problems are found, a "blessing" is issued (sprinkler is 
  short for "holy water sprinkler")
* the compiler (one run) takes one or more blessed units 
  compiles it/them into either a library or an executable
  program.

The interpreter will have a mode in which the reads and writes
that happen on each lexical line of code in a file is recorded.

The information recorded needs to be enough to allow line
coverage to be worked out, and enough to follow a variable
in its home scope and all its subordinate scopes.  This
information should include: file md5, unit name, proc name,
temporal line number, physical line number, local var name,
true var name (unit/proc/localname), local "const-var-type",
true "const/var type", read/write marker.

The information the interpreter saves for the code in a
file is saved in the interpretation (or interpreter) record.
Probably I would save this information in an SQLite database.
The sprinkler will look at the interpretation record to look
for coverage and access problems.

When the sprinkler is given a file to check, it will require
a full set of interpreter records for that file (with the
same MD5 as the current file) to successfully bless the file.

I could use an Adler-32 checksum instead of an MD5.  The intent
of identifying a file by checksum or hash is not to prevent
mischief, but to make it possible for a programmer to get
a positive assurance that the access characteristics of the
file's variables and constants are what the compiler expects.
Having 100% line coverage is not an end in itself, but just
a way to get a strong approximation of each variable's full
access history.

The access history of a single run must conform to the all
variables "const-var-type".  Further, each single run must
(minimally) exit without error.  When the sprinkler analyzes
the collective history of all runs, this analysis must show
that every read-use and write-use of each variable has been
recorded in at least one run.

The compiler will only compile blessed files.

If Yevgenia source files are shared, I would expect that the
shared artifacts would include not just the source files,
but also any scripts and input data required to reproduce
blessed units with the sprinker.

Making programming easier
-------------------------

A number of Yevgeniya's features (like the nondeterministic
IF statement, the total CASE statement, the whole deal 
of blessing via the sprinkler) on the face of it make 
programming harder.

Are there things I could do to make the programming task
easier?   A small thing would be something like golang's 
implicit semicolons.  A larger thing would be having the 
interpreter use ABC2's "epimethean typing" where types 
acquire partial / complete specification only at the 
end of an interpreter run.

[end of file]
